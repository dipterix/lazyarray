% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyarray.R, R/lazymatrix.R
\name{lazyarray}
\alias{lazyarray}
\alias{as.lazyarray}
\alias{as.lazyarray.default}
\alias{as.lazyarray.LazyArray}
\alias{lazymatrix}
\alias{as.lazymatrix}
\alias{as.lazymatrix.default}
\alias{as.lazymatrix.array}
\alias{as.lazymatrix.LazyArray}
\alias{as.lazymatrix.LazyMatrix}
\title{Create or load 'lazyarray' instance}
\usage{
lazyarray(
  path,
  storage_format,
  dim,
  dimnames = NULL,
  compress_level = 50L,
  meta_name = "lazyarray.meta",
  read_only = FALSE,
  quiet = FALSE,
  ...
)

as.lazyarray(x, path, storage_format, ...)

\method{as.lazyarray}{default}(x, path, storage_format, ...)

\method{as.lazyarray}{LazyArray}(x, path, storage_format, meta_name, ...)

lazymatrix(
  path,
  storage_format,
  dim,
  dimnames = NULL,
  multipart = TRUE,
  prefix = "",
  multipart_mode = 1,
  compress_level = 50L,
  file_names = list("", seq_len(dim[[length(dim)]]))[[multipart + 1]],
  meta_name = "lazyarray.meta",
  read_only = FALSE,
  quiet = FALSE,
  ...
)

as.lazymatrix(x, read_only = FALSE, ...)

\method{as.lazymatrix}{default}(x, read_only = FALSE, storage_format, path = tempfile(), ...)

\method{as.lazymatrix}{array}(x, read_only = FALSE, storage_format, path = tempfile(), ...)

\method{as.lazymatrix}{LazyArray}(x, read_only = FALSE, storage_format, ...)

\method{as.lazymatrix}{LazyMatrix}(x, read_only = FALSE, storage_format, ...)
}
\arguments{
\item{path}{path to a local drive where array data is stored}

\item{storage_format}{data type, choices are \code{"double"}, 
\code{"integer"}, \code{"character"}, and \code{"complex"}; see details}

\item{dim}{integer vector, dimension of array, see \code{\link{dim}}}

\item{dimnames}{list of vectors, names of each dimension, see \code{\link{dimnames}}}

\item{compress_level}{0 to 100, level of compression. 0 means
no compression, 100 means maximum compression. For persistent data,
it's recommended to set 100. Default is 50.}

\item{meta_name}{header file name, default is \code{"lazyarray.meta"}}

\item{read_only}{whether created array is read-only}

\item{quiet}{whether to suppress messages, default is false}

\item{...}{ignored or passed to other methods}

\item{x}{R vector, matrix, array or \code{LazyArray}, \code{LazyMatrix}}
}
\description{
If path is missing, create a new array. If path exists and 
meta file is complete, load existing file, otherwise create new meta file
and import from existing data.
}
\details{
The last margin of \code{x} is going to be the partitions of 
\code{LazyArray} instances. For example, a \code{d1 x d2 x d3} 
array will have \code{d3} partitions. Each partition dimension will be 
\code{d1 x d2 x 1}. \code{LazyArray} requires each partition to 
be less than one-third of the total memory size, and number of partitions 
less than 10 thousand for best performance. 

For matrices, \code{as.lazymatrix.array} automatically transposes internal
partitions such that the number of partitions is always less or equal than
each partition length. However, \code{as.lazymatrix.LazyArray} or 
\code{as.lazyarray} don't have such optimization. It's highly recommended
to keep small partition size while having large each partition lengths.
For performance comparisons, see \code{\link{lazy_matmul}}.

When importing from existing partition files generated by 
other packages such as \code{'fst'}, the partition files must be homogeneous,
meaning the stored data length, dimension, and storage type must be the same.
Because \code{'fstcore'} package stores data in data frame internally, 
the column name must be 'V1' for non-complex elements or 
'V1R', 'V1I' for complex numbers (real and imaginary data are stored
in different columns).
}
\examples{

path <- tempfile()

# ---------------- case 1: Create new array ------------------
arr <- lazyarray(path, storage_format = 'double', dim = c(2,3,4), 
                 meta_name = 'lazyarray.meta')
arr[] <- 1:24

# Subset and get the first partition
arr[,,1]

# Partition file path (total 4 partitions)
arr$get_partition_fpath()

# Removing array doesn't clear the data
rm(arr); gc()

# ---------------- Case 2: Load from existing directory ----------------
## Important!!! Run case 1 first
# Load from existing path, no need to specify other params
arr <- lazyarray(path, meta_name = 'lazyarray.meta', read_only = TRUE)

arr[,,1]

# ---------------- Case 3: Import from existing data ----------------
## Important!!! Run case 1 first

# path exists, but meta is missing, all other params are required
# Notice the partition count increased from 4 to 5, and storage type converts
# from double to character
arr <- lazyarray(path = path, meta_name = 'lazyarray-character.meta', 
                 file_names = c(1,2,3,4,'additional'), 
                 storage_format = 'character', dim = c(2,3,5), 
                 quiet = TRUE, read_only = FALSE)

# partition names
arr$get_partition_fpath(1:4, full_path = FALSE)
arr$get_partition_fpath(5, full_path = FALSE)

# The first dimension still exist and valid
arr[,,1]

# The additional partition is all NA
arr[,,5]

# Set data to 5th partition
arr[,,5] <- rep(0, 6)

# ---------------- Case 3: Converting from R arrays ----------------

x <- matrix(1:16, 4)
x <- as.lazymatrix(x)
x[,]


x <- array(1:27, c(3,3,3))
as.lazymatrix(x)[,1]

as.lazyarray(x)[]

# -------- Advanced usage: create fst data and import manually --------

# Clear existing files
path <- tempfile()
unlink(path, recursive = TRUE)
dir.create(path, recursive = TRUE)

# Create array of dimension 2x3x4, but 3rd partition is missing
# without using lazyarray package 

# Column names must be V1 or V1R, V1I (complex)
fst::write_fst(data.frame(V1 = 1:6), path = file.path(path, 'part-1.fst'))
fst::write_fst(data.frame(V1 = 7:12), path = file.path(path, 'part-B.fst'))
fst::write_fst(data.frame(V1 = 19:24), path = file.path(path, 'part-d.fst'))

# Import via lazyarray
arr <- lazyarray(path, meta_name = 'test-int.meta',
                 storage_format = 'integer',
                 dim = c(2,3,4), prefix = 'part-', 
                 file_names = c('1', 'B', 'C', 'd'), 
                 quiet = TRUE)

arr[]

# Complex case
fst::write_fst(data.frame(V1R = 1:6, V1I = 1:6), 
               path = file.path(path, 'cplx-1.fst'))
fst::write_fst(data.frame(V1R = 7:12, V1I = 100:105), 
               path = file.path(path, 'cplx-2.fst'))
fst::write_fst(data.frame(V1R = 19:24, V1I = rep(0,6)), 
               path = file.path(path, 'cplx-4.fst'))
arr <- lazyarray(path, meta_name = 'test-cplx.meta',
                 storage_format = 'complex',
                 dim = c(2,3,4), prefix = 'cplx-', 
                 file_names = 1:4, quiet = TRUE)

arr[]

}
\seealso{
\code{\link{create_lazyarray}}, \code{\link{load_lazyarray}}
}
\author{
Zhengjia Wang
}
